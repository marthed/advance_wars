<html>
  <head>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="stats" class="stats">
      <div id="stats-day" class="stats-item">DAY: 1</div>
      <div id="stats-player" class="stats-item">PLAYER 1</div>
      <button id="end-turn" class="stats-button">End turn</button>
    </div>
    <div id="map" class="grid-container"></div>
    <div id="unit-action-modal" class="hidden">
      <div class="unit-action-modal__option">Attack</div>
      <div class="delimeter"></div>
      <div class="unit-action-modal__option">No Attack</div>
    </div>

    <script>
      let GlobalState = {
        path: [], // TileData for current unit path
        currentTileId: null, // number
        currentSelectedUnitTile: null, // element
        currentSelectedUnitElement: null,
        adjacentEnemyTiles: [],
        targetEnemyUnitTile: null,
        units: { 1: {}, 2: {}, 3: {}, 4: {} },
        turn: 1,
        playerTurn: 1,
        numberOfPlayers: 2,
        playerColors: { 1: 'green', 2: 'red', 3: 'blue', 4: 'yellow' },
        terrain: {
          htmlMap: null,
          waterTiles: [],
        },
      };
    </script>

    <script>
      /* Terrain Generation */
      function CreateTerrainImage(terrainType, config = {}) {
        const img = document.createElement('img');
        img.classList.add('terrain-image');

        if (terrainType === 'road') {
          const { road } = config;

          if (road === 'horizontal') {
            img.src = 'terrain/road_straight.png';
          } else if (road === 'vertical') {
            img.src = 'terrain/road_straight.png';
            img.classList.add(`road--${road}`);
          } else if (road === 'right-up') {
            img.src = 'terrain/road_curved.png';
            img.classList.add(`road--${road}`);
          } else if (road === 'left-up') {
            img.src = 'terrain/road_curved.png';
            img.classList.add(`road--${road}`);
          } else if (road === 'right-down') {
            img.src = 'terrain/road_curved.png';
            img.classList.add(`road--${road}`);
          } else if (road === 'left-down') {
            img.src = 'terrain/road_curved.png';
            img.classList.add(`road--${road}`);
          } else {
            img.src = 'terrain/road_straight.png';
          }

          return img;
        }

        img.src = `terrain/${terrainType}.png`;

        return img;
      }
    </script>

    <script>
      function GetSavedTerrain() {
        const item = window.localStorage.getItem('terrain');

        if (item) {
          const savedTerrain = item.split(',');
          return savedTerrain;
        }
      }

      const roadMappings = [
        160, 161, 162, 163, 164, 165, 205, 245, 246, 247, 248, 249, 250, 251,
        252, 212, 172, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 101,
        61, 21,
      ];

      function GenerateSavedTerrain(savedTerrain = []) {
        const serializableTerrainMap = [];

        for (let i = 0; i < savedTerrain.length; i++) {
          const element = document.createElement('div');
          element.classList.add('grid-item');
          element.id = 'tile-' + i;

          const roadIndex = roadMappings.find((tileIndex) => tileIndex === i);

          if (roadIndex) {
            CreateRoad(element);
            serializableTerrainMap.push('road');
          } else {
            element.classList.add(`terrain-${savedTerrain[i]}`);
            const img = CreateTerrainImage(savedTerrain[i]);
            element.appendChild(img);

            if (savedTerrain[i] === 'water') {
              GlobalState.terrain.waterTiles.push(img);
            }
          }

          const path = document.createElement('div');
          path.classList.add('path');

          element.appendChild(path);

          GlobalState.terrain.htmlMap.appendChild(element);
        }
      }

      function CreateRoad(tile) {
        const tileIndex = Number(tile.id.split('-')[1]);
        tile.classList.add('terrain-road');

        const roadMappingIndex = roadMappings.indexOf(tileIndex);

        const surroundingTiles = [
          tileIndex - 1,
          tileIndex + 1,
          tileIndex - 40,
          tileIndex + 40,
        ];

        const previous = roadMappings[roadMappingIndex - 1];
        const next = roadMappings[roadMappingIndex + 1];

        const previousTileID = surroundingTiles.find(
          (tileId) => previous === tileId
        );
        const nextTileID = surroundingTiles.find((tileId) => next === tileId);

        let img;

        if (!previousTileID && !nextTileID) {
          img = CreateTerrainImage('road', { road: 'horizontal' });
        } else if (
          (previousTileID && !nextTileID) ||
          (!previousTileID && nextTileID)
        ) {
          const diff =
            tileIndex - (previousTileID ? previousTileID : nextTileID);
          if (diff === 1 || diff === -1) {
            img = CreateTerrainImage('road', { road: 'horizontal' });
          } else if (diff === 40 || diff === -40) {
            img = CreateTerrainImage('road', { road: 'vertical' });
          }
        } else {
          const diffPrevious = tileIndex - previousTileID;
          const diffNext = nextTileID - tileIndex;
          const modify = GetRoadDirection(diffPrevious, diffNext);

          img = CreateTerrainImage('road', { road: modify });
        }

        tile.appendChild(img);
      }

      function GetRoadDirection(previous, next) {
        if (previous === 1) {
          if (next === 1) {
            return 'horizontal';
          }

          if (next === 40) {
            return 'left-down';
          }

          if (next === -40) {
            return 'left-up';
          }
        } else if (previous === -1) {
          if (next === -1) {
            return 'horizontal';
          }

          if (next === -40) {
            return 'right-up';
          }

          if (next === 40) {
            return 'right-down';
          }
        } else if (previous === 40) {
          // From above
          if (next === 1) {
            return 'right-up';
          }

          if (next === -1) {
            return 'left-up';
          }

          if (next === 40) {
            return 'vertical';
          }
        } else if (previous === -40) {
          // From below
          if (next === 1) {
            return 'right-down';
          }

          if (next === -1) {
            return 'left-down';
          }

          if (next === -40) {
            return 'vertical';
          }
        }
      }

      function GenerateNewTerrain(size) {
        const serializableTerrainMap = [];

        for (let i = 0; i < size; i++) {
          const element = document.createElement('div');
          element.classList.add('grid-item');
          element.id = 'tile-' + i;

          const roadIndex = roadMappings.find((tileIndex) => tileIndex === i);
          if (roadIndex) {
            CreateRoad(element);
            serializableTerrainMap.push('road');
          } else {
            if (i < size / 2) {
              if (Math.random() < 0.2) {
                element.classList.add('terrain-forest');
                const img = CreateTerrainImage('forest');
                element.appendChild(img);
                serializableTerrainMap.push('forest');
              } else if (Math.random() < 0.1) {
                element.classList.add('terrain-mountain');
                const img = CreateTerrainImage('mountain');
                element.appendChild(img);
                serializableTerrainMap.push('mountain');
              } else {
                element.classList.add('terrain-field');
                const img = CreateTerrainImage('field');
                element.appendChild(img);
                serializableTerrainMap.push('field');
              }
            } else if (i < 440) {
              element.classList.add('terrain-shore');
              const img = CreateTerrainImage('shore');
              element.appendChild(img);
              serializableTerrainMap.push('shore');
            } else {
              element.classList.add('terrain-water');
              const img = CreateTerrainImage('water');
              element.appendChild(img);
              GlobalState.terrain.waterTiles.push(img);
              serializableTerrainMap.push('water');
            }
          }

          const path = document.createElement('div');
          path.classList.add('path');

          element.appendChild(path);

          GlobalState.terrain.htmlMap.appendChild(element);
        }
        window.localStorage.setItem('terrain', serializableTerrainMap);
      }
    </script>

    <script>
      /* Generate Map */
      GlobalState.terrain.htmlMap = document.getElementById('map');
      GlobalState.terrain.waterTiles = [];

      const terrain = GetSavedTerrain();
      if (terrain) {
        GenerateSavedTerrain(terrain);
      } else {
        const size = 20 * 40;
        GenerateNewTerrain(size);
      }
    </script>
    <script></script>

    <script>
      /* Water animation */
      const { waterTiles } = GlobalState.terrain;

      const WaterAnimation = {
        numberOfTilesPerInterval: waterTiles.length,
        max: waterTiles.length - 1,
        min: 0,
        paths: ['water.png', 'water_1.png', 'water_2.png', 'water_3.png'],
      };

      setInterval(() => {
        const { numberOfTilesPerInterval, max, min, paths } = WaterAnimation;

        for (let i = 0; i < numberOfTilesPerInterval; i++) {
          const index = Math.floor(Math.random() * (max - min + 1)) + min;
          const image = Math.floor(Math.random() * (3 - 0 + 1)) + 0;

          waterTiles[index].src = `terrain/${paths[image]}`;
        }
      }, 2000);
    </script>

    <script>
      /* Classes */
      class TileData {
        id = '';
        terrainColor = '';
        element = null;
        command = '';

        constructor(id, t, e, c) {
          this.id = id;
          this.terrainColor = t;
          this.element = e;
          this.command = c;
        }
      }

      class Unit {
        id = '';
        type = '';
        movementRange = 0;
        canMoveInTerrain = [
          'field',
          'forest',
          'mountain',
          'water',
          'road',
          'shore',
        ];
        tileElement = null;
        hitPoints = 100;
        directAttack = true;
        attackRange = 0;

        constructor(type) {
          this.id = GenerateId();
          this.type = type;
          const {
            canMoveInTerrain,
            movementRange,
            directAttack = true,
            attackRange = 0,
          } = GetUnitLogic(type);
          this.canMoveInTerrain = canMoveInTerrain;
          this.movementRange = movementRange;
          this.directAttack = directAttack;
          this.attackRange = attackRange;
        }
      }
    </script>

    <script>
      /* Audio */
      const AudioPlayer = new Audio();

      const baseUrl = 'audio/';

      function PlaySound(type) {
        AudioPlayer.pause();

        switch (type) {
          case 'infantry_walk':
            AudioPlayer.src = baseUrl + 'infantry_walk.wav';
            break;
          case 'infantry_fire':
            AudioPlayer.src = baseUrl + 'infantry_fire.wav';
            break;
        }

        if (AudioPlayer.src) {
          AudioPlayer.load();
          AudioPlayer.play();
        }
      }

      function PlayMovementSound() {
        const { currentSelectedUnitElement, playerTurn, units } = GlobalState;

        const unit = units[playerTurn][currentSelectedUnitElement.id];

        if (unit.type === 'infantry') {
          PlaySound('infantry_walk');
        } else if (unit.type === 'rpg') {
          PlaySound('infantry_walk');
        }
      }
    </script>
    <script>
      /* Functions */

      function GenerateId() {
        return 'unitId-' + Date.now() + '-' + Math.floor(Math.random() * 10000);
      }

      function GetUnitLogic(type = '') {
        if (type === 'infantry') {
          return {
            movementRange: 3,
            canMoveInTerrain: ['field', 'forest', 'mountain', 'road', 'shore'],
          };
        }
        if (type === 'tank') {
          return {
            movementRange: 6,
            canMoveInTerrain: ['field', 'forest', 'road', 'shore'],
          };
        }
        if (type === 'rpg') {
          return {
            movementRange: 2,
            canMoveInTerrain: ['field', 'forest', 'mountain', 'road', 'shore'],
          };
        }
        if (type === 'rockets') {
          return {
            movementRange: 6,
            canMoveInTerrain: ['field', 'forest', 'road', 'shore'],
            directAttack: false,
            attackRange: 5,
            minAttackRange: 2,
          };
        }
        if (type === 'battleship') {
          return {
            movementRange: 5,
            canMoveInTerrain: ['water'],
            directAttack: false,
            attackRange: 6,
            minAttackRange: 2,
          };
        }

        return { movementRange: 0, canMoveInTerrain: [] };
      }

      function SetHitPoints(unit) {
        const unitElement = unit.tileElement.querySelector('div.unit');
        const hp = unitElement.querySelector('span.hp');

        const hitPoints = Math.round(Number(unit.hitPoints));

        if (hitPoints === 100) {
          hp.innerHTML = String(hitPoints);
        } else if (hitPoints > 9) {
          hp.innerHTML = String(hitPoints).substring(0, 2);
        } else {
          hp.innerHTML = String(hitPoints);
        }
      }

      function CreateUnitElement(unit, player) {
        const element = document.createElement('div');
        element.classList.add('unit');
        element.setAttribute('player', player);

        const unitImage = CreateUnitImage(unit, player);

        const hpElement = document.createElement('span');
        hpElement.classList.add('hp');
        hpElement.style.zIndex = '2';

        const color = GlobalState.playerColors[player];
        hpElement.classList.add(`color-${color}`);

        element.appendChild(unitImage);
        element.appendChild(hpElement);

        element.id = unit.id;

        return element;
      }

      function CreateUnitImage(unit, player) {
        const { type, id } = unit;
        const img = document.createElement('img');

        const color = GlobalState.playerColors[player];

        if (type === 'infantry') {
          img.src = `units/${type}_${color}.png`;
        } else if (type === 'rpg') {
          img.src = `units/infantry_${type}_${color}.png`;
        } else if (type === 'rockets') {
          img.src = `units/${type}_${color}.png`;
        } else {
          img.src = `units/${type}.png`;
        }

        img.classList.add('overlay-image');
        img.classList.add('unit-image');

        if (player === 2) {
          img.classList.add('flipped-right');
        }

        return img;
      }

      function AddTileData(elem, command) {
        const id = elem.id.split('-')[1];
        const terrain = window
          .getComputedStyle(elem, null)
          .getPropertyValue('background-color');
        const tileData = new TileData(id, terrain, elem, command);
        return tileData;
      }

      function GetNextTileNumber(key) {
        const currentTileId = Number(
          GlobalState.currentTileId ||
            GlobalState.currentSelectedUnitTile.id.split('-')[1]
        );

        switch (key) {
          case 'ArrowUp':
            return currentTileId - 40;
          case 'ArrowDown':
            return currentTileId + 40;
          case 'ArrowLeft':
            return currentTileId - 1;
          case 'ArrowRight':
            return currentTileId + 1;
          default:
            -1;
        }
      }

      function GetUnitIDFromTerrainElement(terrainElement) {
        return terrainElement.querySelector(`div.unit`)?.id;
      }

      function GetTileId(terrainElement) {
        return Number(terrainElement.id.split('-')[1]);
      }

      function GetTerrainType(terrainElement) {
        const terrain = Array.from(terrainElement.classList)
          .find((c) => c.split('-')[0] === 'terrain')
          .split('-')[1];

        return terrain;
      }

      function CanMoveInTerrain(terrainElement) {
        const id = GetUnitIDFromTerrainElement(
          GlobalState.currentSelectedUnitTile
        );

        const unit = GlobalState.units[GlobalState.playerTurn][id];

        if (!unit) {
          console.log(`No unit found for ${id}`);
          return false;
        }
        const terrain = Array.from(terrainElement.classList).find(
          (c) => c.split('-')[0] === 'terrain'
        );

        if (!terrain) {
          console.log(`Not a terrain: ${terrain}`);
          return false;
        }

        const canMove = !!unit.canMoveInTerrain.find(
          (t) => t === terrain.split('-')[1]
        );

        return canMove;
      }

      function IsUndoMove(key, nextTile) {
        const { path } = GlobalState;

        const lastTile = path[path.length - 1];

        switch (key) {
          case 'ArrowUp':
            return lastTile.command === 'ArrowDown';
          case 'ArrowDown':
            return lastTile.command === 'ArrowUp';
          case 'ArrowLeft':
            return lastTile.command === 'ArrowRight';
          case 'ArrowRight':
            return lastTile.command === 'ArrowLeft';
          default:
            return false;
        }
      }

      function UndoMove(elem) {
        const { path } = GlobalState;

        const lastTile = path[path.length - 1];

        document
          .getElementById(`tile-${lastTile.id}`)
          .querySelector('.path')
          .classList.remove('path__highlighted');

        GlobalState.path.pop();
        GlobalState.currentTileId = Number(elem.id.split('-')[1]);
      }

      function AlreadyMovedOnTile(nextTileNumber) {
        const { path } = GlobalState;

        return !!path.find(
          (tileData) => Number(tileData.id) === nextTileNumber
        );
      }

      function TileIsOccupied(elem) {
        const selectedUnitId = GlobalState.currentSelectedUnitElement.id;

        const idOnTile = GetUnitIDFromTerrainElement(elem);

        return idOnTile && idOnTile !== selectedUnitId;
      }

      function AddPath(key, nextTileElem) {
        GlobalState.currentTileId = Number(nextTileElem.id.split('-')[1]);
        const tileData = AddTileData(nextTileElem, key);
        GlobalState.path.push(tileData);

        nextTileElem.querySelector('.path').classList.add('path__highlighted');

        //nextTileElem.style.backgroundColor = 'purple';
      }

      function RemoveUnitElement() {
        document.removeEventListener('keydown', EventListener);

        const unitElement =
          GlobalState.currentSelectedUnitTile.querySelector('div.unit');

        GlobalState.currentSelectedUnitElement = unitElement;

        GlobalState.currentSelectedUnitTile.removeChild(unitElement);
      }

      function AddUnitElement(settings = {}) {
        const { currentTileId, units, playerTurn } = GlobalState;
        const terrainElement =
          settings.tile || document.getElementById(`tile-${currentTileId}`);
        const unitElement = GlobalState.currentSelectedUnitElement;
        const id = unitElement.id;

        units[playerTurn][id].tileElement = terrainElement;

        terrainElement.appendChild(unitElement);
        if (settings.canMove) {
          terrainElement.addEventListener('mousedown', SelectUnit);
        }
        if (settings.hasMoved) {
          unitElement.classList.add('hasMoved');
        }

        if (settings.flipped) {
          unitElement
            .querySelector('img.unit-image')
            .classList.add('flipped-right');
          //unitElement.classList.add('flipped-right');
        }
      }

      function ResetPath() {
        GlobalState.path.forEach((tile) => {
          tile.element
            .querySelector('.path')
            .classList.remove('path__highlighted');
          //tile.element.style.backgroundColor = tile.terrainColor;
        });
        GlobalState.path = [];
      }

      function ResetSelectedTile() {
        GlobalState.currentSelectedUnitTile = null;
        GlobalState.currentTileId = null;
        GlobalState.currentSelectedUnitElement = null;
      }

      function ReachedMovementRange() {
        const { currentSelectedUnitElement, path, playerTurn } = GlobalState;

        const currentUnit =
          GlobalState.units[playerTurn][currentSelectedUnitElement.id];

        const terrainInPath = path.map((tileData) =>
          GetTerrainType(tileData.element)
        );

        let reduceField = 0;
        let reduceForest = 0;
        let reduceMountain = 0;
        let reduceShore = 0;

        const containsMountain = terrainInPath.some((t) => t === 'mountain');
        const containsForest = terrainInPath.some((t) => t === 'forest');
        const containsField = terrainInPath.some((t) => t === 'field');
        const containsShore = terrainInPath.some((t) => t === 'shore');

        if (currentUnit.type === 'tank') {
          reduceField = containsField ? 0 : 0;
          reduceForest = containsForest ? 2 : 0;
          reduceMountain = containsMountain ? 0 : 0;
        } else if (currentUnit.type === 'infantry') {
          reduceField = containsField ? 0 : 0;
          reduceForest = containsForest ? 0 : 0;
          reduceMountain = containsMountain ? 1 : 0;
        } else if (currentUnit.type === 'rpg') {
          reduceField = containsField ? 0 : 0;
          reduceForest = containsForest ? 0 : 0;
          reduceMountain = containsMountain ? 1 : 0;
        } else if (currentUnit.type === 'rockets') {
          reduceField = containsField ? 1 : 0;
          reduceForest = containsForest ? 3 : 0;
          reduceMountain = containsMountain ? 1 : 0;
          reduceShore = containsShore ? 2 : 0;
        }

        const reduction =
          Number(reduceField) +
          Number(reduceForest) +
          Number(reduceMountain) +
          Number(reduceShore);

        return path.length >= currentUnit.movementRange + 1 - reduction;
      }

      function EndTurn() {
        const { playerTurn, numberOfPlayers, units } = GlobalState;

        DeselectUnit();

        // Remove event listeners for the current player's units
        Object.keys(units[playerTurn]).forEach((id) => {
          units[playerTurn][id].tileElement.removeEventListener(
            'mousedown',
            SelectUnit
          );
          const movedUnit =
            units[playerTurn][id].tileElement.querySelector('.hasMoved');

          if (movedUnit) {
            movedUnit.classList.remove('hasMoved');
          }
        });

        const previousPlayer = GlobalState.playerTurn;

        // Update the player turn
        if (playerTurn === numberOfPlayers) {
          GlobalState.turn++;
          GlobalState.playerTurn = 1;
        } else {
          GlobalState.playerTurn++;
        }

        // Update the stats display
        document.getElementById('stats-day').innerHTML =
          'DAY ' + GlobalState.turn;
        document.getElementById('stats-player').innerHTML =
          'PLAYER ' + GlobalState.playerTurn;

        const previousColor = GlobalState.playerColors[previousPlayer];
        const newColor = GlobalState.playerColors[GlobalState.playerTurn];

        document
          .getElementById('stats-player')
          .classList.remove(`color-${previousColor}`);
        document
          .getElementById('stats-player')
          .classList.add(`color-${newColor}`);

        // Add event listeners for the new player's units
        Object.keys(units[GlobalState.playerTurn]).forEach((id) => {
          units[GlobalState.playerTurn][id].tileElement.addEventListener(
            'mousedown',
            SelectUnit
          );
        });
      }

      function GetUnitFromElement(element) {
        return element.querySelector('div.unit');
      }

      function DeselectUnit() {
        document.removeEventListener('keydown', EventListener);
        GlobalState.currentSelectedUnitTile?.addEventListener(
          'mousedown',
          SelectUnit
        );

        ResetPath();
        ResetSelectedTile();
      }

      function MapDirection(id) {
        const { currentTileId } = GlobalState;
        if (currentTileId - 1 === id) {
          return 'ArrowLeft';
        }
        if (currentTileId + 1 === id) {
          return 'ArrowRight';
        }
        if (currentTileId - 40 === id) {
          return 'ArrowUp';
        }
        if (currentTileId + 40 === id) {
          return 'ArrowDown';
        }
      }

      function CheckRangedAttackTarget() {}

      function RemoveUnitActionModalEvents() {
        document.removeEventListener('keydown', UnitActionModalEvents);

        const modal = document.getElementById('unit-action-modal');

        const actions = modal.querySelectorAll('div.unit-action-modal__option');

        const attack = actions[0];
        const noAttack = actions[1];

        attack.removeEventListener('click', Attack);
        noAttack.removeEventListener('click', NoAttack);
      }

      function CloseUnitActionModal() {
        RemoveUnitActionModalEvents();
        ResetTargetEnemy();

        const modal = document.getElementById('unit-action-modal');
        modal.classList.add('hidden');
      }

      const UnitActionModalEvents = (event) => {
        const { key } = event;
        if (key === 'Escape') {
          CloseUnitActionModal();
          SelectTargetEnemy();
        }

        if (key === 'Enter') {
          PreAttack();
        }
      };

      const PreAttack = () => {
        RemoveUnitActionModalEvents();
        CloseUnitActionModal();
        Attack();
        //RemoveUnitElement();
        if (GlobalState.currentSelectedUnitElement) {
          AddUnitElement({
            hasMoved: true,
            canMove: false,
            flipped: GlobalState.playerTurn === 2,
          });
        }

        ResetSelectedTile();
      };

      const NoAttack = () => {
        RemoveUnitActionModalEvents();
        CloseUnitActionModal();
        //RemoveUnitElement();
        AddUnitElement({
          hasMoved: true,
          canMove: false,
          flipped: GlobalState.playerTurn === 2,
        });
        ResetSelectedTile();
      };

      function OpenUnitActionModal() {
        const { currentTileId } = GlobalState;
        const currentTile = document.getElementById(`tile-${currentTileId}`);

        document.getElementById('map').style.overflow = 'hidden';

        const modal = document.getElementById('unit-action-modal');
        modal.classList.remove('hidden');

        const rect = currentTile.getBoundingClientRect();
        modal.style.left = rect.left + 50 + 'px';
        modal.style.top = rect.top + 50 + 'px';

        const actions = modal.querySelectorAll('div.unit-action-modal__option');

        const attack = actions[0];
        const noAttack = actions[1];

        attack.addEventListener('click', PreAttack);
        noAttack.addEventListener('click', NoAttack);
        document.addEventListener('keydown', UnitActionModalEvents);
      }

      function ResetTargetEnemy() {
        const { adjacentEnemyTiles } = GlobalState;

        adjacentEnemyTiles.forEach(({ tileElement }) => {
          tileElement
            .querySelector('.path')
            .classList.remove('path__highlighted--attack'); // Change to image later
        });
      }

      function HandleSelectRangedTarget(command) {
        const { adjacentEnemyTiles, targetEnemyUnitTile, currentTileId } =
          GlobalState;

        const currentEnemyTileId = adjacentEnemyTiles.find(
          ({ tileElement }) =>
            GetTileId(tileElement) === GetTileId(targetEnemyUnitTile)
        );

        const index = adjacentEnemyTiles.indexOf(currentEnemyTileId);

        if (command === 'ArrowRight') {
          const nextIndex =
            index + 1 === adjacentEnemyTiles.length ? 0 : index + 1;
          return adjacentEnemyTiles[nextIndex];
        }
        if (command === 'ArrowLeft') {
          const nextIndex =
            index - 1 < 0 ? adjacentEnemyTiles.length - 1 : index - 1;
          return adjacentEnemyTiles[nextIndex];
        }
        if (command === 'ArrowDown') {
          const nextIndex =
            index - 1 < 0 ? adjacentEnemyTiles.length - 1 : index - 1;
          return adjacentEnemyTiles[nextIndex];
        }
        if (command === 'ArrowUp') {
          const nextIndex =
            index + 1 === adjacentEnemyTiles.length ? 0 : index + 1;
          return adjacentEnemyTiles[nextIndex];
        }
        return targetEnemyUnitTile;
      }

      function ChangeTargetEnemy() {
        const { key } = event;
        const {
          adjacentEnemyTiles,
          currentSelectedUnitElement,
          units,
          playerTurn,
        } = GlobalState;

        const unit = units[playerTurn][currentSelectedUnitElement.id];
        const actions = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];

        if (unit.directAttack === false) {
          if (actions.find((command) => command === key)) {
            const enemyTile = HandleSelectRangedTarget(key);

            if (enemyTile) {
              ResetTargetEnemy();

              enemyTile.tileElement
                .querySelector('.path')
                .classList.add('path__highlighted--attack'); // Change to image later

              GlobalState.targetEnemyUnitTile = enemyTile.tileElement;
            }
          }
        } else {
          if (actions.find((command) => command === key)) {
            const enemyTile = adjacentEnemyTiles.find(
              (tile) => tile.direction === key
            );

            if (enemyTile) {
              ResetTargetEnemy();

              enemyTile.tileElement
                .querySelector('.path')
                .classList.add('path__highlighted--attack'); // Change to image later

              GlobalState.targetEnemyUnitTile = enemyTile.tileElement;
            }
          }
        }

        if (key === 'Enter') {
          document.removeEventListener('keydown', ChangeTargetEnemy);
          OpenUnitActionModal();
          return;
        }

        if (key === 'Escape') {
          document.removeEventListener('keydown', ChangeTargetEnemy);

          adjacentEnemyTiles.forEach(({ tileElement }) => {
            tileElement
              .querySelector('.path')
              .classList.remove('path__highlighted--attack'); // Change to image later
          });

          AddUnitElement({
            tile: GlobalState.currentSelectedUnitTile,
            flipped: GlobalState.playerTurn === 2,
            hasMoved: false,
            canMove: true,
          });

          ResetSelectedTile();
        }
      }

      function SelectTargetEnemy() {
        const { currentTileId, adjacentEnemyTiles } = GlobalState;
        const currentTile = document.getElementById(`tile-${currentTileId}`);

        document.getElementById('map').style.overflow = 'hidden';

        const firstEnemy = adjacentEnemyTiles[0];
        firstEnemy.tileElement
          .querySelector('.path')
          .classList.add('path__highlighted--attack');

        GlobalState.targetEnemyUnitTile = firstEnemy.tileElement;

        if (adjacentEnemyTiles.length > 1) {
          document.addEventListener('keydown', ChangeTargetEnemy);
        } else {
          OpenUnitActionModal();
        }
      }

      function AdjacentEnemyUnits(options = {}) {
        const { currentTileId, playerTurn, currentSelectedUnitElement, units } =
          GlobalState;

        const unit = units[playerTurn][currentSelectedUnitElement.id];

        let surroundingTiles = [];

        if (unit.attackRange && !options.range) {
          return false;
        }

        if (unit.attackRange) {
          const attackRange = unit.attackRange;

          for (let i = attackRange; i > -1; i--) {
            let up;
            let down;

            if (i !== 0) {
              up = currentTileId + -40 * i;
              down = currentTileId + 40 * i;
              surroundingTiles.push(up);
              surroundingTiles.push(down);

              // const upElem = document.getElementById('tile-' + up);
              // AddPath('ArrowUp', upElem);

              // const downElem = document.getElementById('tile-' + down);
              // AddPath('ArrowUp', downElem);
            }

            const rowTiles = attackRange - i;

            for (let j = 1; j < rowTiles + 1; j++) {
              if (i === 0) {
                const left = currentTileId - j;
                const right = currentTileId + j;
                surroundingTiles.push(left);
                surroundingTiles.push(right);
                // AddPath('ArrowUp', document.getElementById('tile-' + left));
                // AddPath('ArrowUp', document.getElementById('tile-' + right));

                const hej = 0;
              } else {
                const upLeft = up - j;
                const upRight = up + j;

                const downLeft = down - j;
                const downRight = down + j;

                // AddPath('ArrowUp', document.getElementById('tile-' + upLeft));
                // AddPath('ArrowUp', document.getElementById('tile-' + upRight));
                // AddPath('ArrowUp', document.getElementById('tile-' + downLeft));
                // AddPath(
                //   'ArrowUp',
                //   document.getElementById('tile-' + downRight)
                // );

                surroundingTiles.push(upLeft);
                surroundingTiles.push(upRight);
                surroundingTiles.push(downLeft);
                surroundingTiles.push(downRight);
              }
            }
          }
        } else {
          surroundingTiles = [
            currentTileId - 1,
            currentTileId + 1,
            currentTileId - 40,
            currentTileId + 40,
          ];
        }

        surroundingTiles = surroundingTiles
          .map((id) => ({
            tileElement: document.getElementById(`tile-${id}`),
            direction: options.range ? null : MapDirection(id),
          }))
          .filter((tile) => !!tile.tileElement);

        const enemyTiles = surroundingTiles.filter(
          ({ tileElement, direction }) => {
            const unit = GetUnitFromElement(tileElement);
            if (unit) {
              if (Number(unit.getAttribute('player')) !== playerTurn) {
                return true;
              }
              return false;
            }
            return false;
          }
        );

        if (!enemyTiles.length) {
          return false;
        }

        GlobalState.adjacentEnemyTiles = enemyTiles;

        return true;
      }

      function EnemyUnitBlocking(nextTile) {
        const unitElement = nextTile.querySelector('div.unit');

        if (!unitElement) {
          return false;
        }

        const player = unitElement.getAttribute('player');

        if (Number(player) === Number(GlobalState.playerTurn)) {
          return false;
        }

        return true;
      }
      function CheckRangeAttack() {
        const { currentSelectedUnitElement, playerTurn, path } = GlobalState;

        if (!currentSelectedUnitElement) {
          return false;
        }

        if (path.length > 1) {
          return false;
        }

        const unit =
          GlobalState.units[playerTurn][currentSelectedUnitElement.id];

        if (!unit.directAttack) {
          return true;
        }
      }
    </script>

    <script>
      /* Combat Logic */

      function TerrainBonus(terrainType) {
        if (terrainType === 'field') {
          return 1.25;
        }
        if (terrainType === 'forest') {
          return 1.5;
        }
        if (terrainType === 'mountain') {
          return 2;
        }
        if (terrainType === 'water') {
          return 1;
        }
        if (terrainType === 'road') {
          return 1;
        }
        if (terrainType === 'shore') {
          return 1;
        }
      }

      function UnitDeath(unit, player) {
        const unitElement = unit.tileElement.querySelector('div.unit');

        unit.tileElement.removeChild(unitElement);

        delete GlobalState.units[player][unit.id];

        // TODO: Do some animation
      }

      function Attack() {
        const {
          currentSelectedUnitElement,
          currentSelectedUnitTile,
          targetEnemyUnitTile,
          playerTurn,
          currentTileId,
        } = GlobalState;

        const enemyElement = GetUnitFromElement(targetEnemyUnitTile);

        const attackUnit =
          GlobalState.units[playerTurn][currentSelectedUnitElement.id];

        const defenceUnit =
          GlobalState.units[enemyElement.getAttribute('player')][
            enemyElement.id
          ];

        const attackTerrain = GetTerrainType(
          document.getElementById(`tile-${currentTileId}`)
        );
        const defenceTerrain = GetTerrainType(targetEnemyUnitTile);

        if (attackUnit.type === 'infantry') {
          PlaySound('infantry_fire');
          if (defenceUnit.type === 'infantry') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 50, attackTerrain },
              { defenceUnit, defenderStength: 50, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rpg') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 50, attackTerrain },
              { defenceUnit, defenderStength: 50, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'tank') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 10, attackTerrain },
              { defenceUnit, defenderStength: 80, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'battleship') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 1, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rockets') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 50, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
        }

        if (attackUnit.type === 'rpg') {
          if (defenceUnit.type === 'infantry') {
            PlaySound('infantry_fire');
            CalculateHitPoints(
              { attackUnit, attackerStength: 50, attackTerrain },
              { defenceUnit, defenderStength: 50, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rpg') {
            PlaySound('infantry_fire');
            CalculateHitPoints(
              { attackUnit, attackerStength: 50, attackTerrain },
              { defenceUnit, defenderStength: 50, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'tank') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 40, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'battleship') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 20, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rockets') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 70, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
        }

        if (attackUnit.type === 'tank') {
          if (defenceUnit.type === 'infantry') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 10, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rpg') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 70, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'tank') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 60, attackTerrain },
              { defenceUnit, defenderStength: 50, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'battleship') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 20, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rockets') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
        }

        if (attackUnit.type === 'battleship') {
          if (defenceUnit.type === 'infantry') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rpg') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'tank') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 60, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'battleship') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 50, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rockets') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 70, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
        }

        if (attackUnit.type === 'rockets') {
          if (defenceUnit.type === 'infantry') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rpg') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 80, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'tank') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 60, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'battleship') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 30, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
          if (defenceUnit.type === 'rockets') {
            CalculateHitPoints(
              { attackUnit, attackerStength: 50, attackTerrain },
              { defenceUnit, defenderStength: 0, defenceTerrain }
            );
          }
        }

        if (attackUnit.hitPoints < 1) {
          ResetSelectedTile();
          UnitDeath(attackUnit, playerTurn);
        } else {
          SetHitPoints(attackUnit);
        }

        if (defenceUnit.hitPoints < 1) {
          UnitDeath(defenceUnit, enemyElement.getAttribute('player'));
        } else {
          SetHitPoints(defenceUnit);
        }
      }

      function CalculateHitPoints(a, d) {
        const { attackUnit, attackerStength, attackTerrain } = a;
        const { defenceUnit, defenderStength, defenceTerrain } = d;

        const attackerDamage = attackerStength * (attackUnit.hitPoints / 100);
        const attackerDamageAfterTerrain =
          attackerDamage / TerrainBonus(defenceTerrain);

        defenceUnit.hitPoints =
          defenceUnit.hitPoints - attackerDamageAfterTerrain;

        if (defenceUnit.hitPoints > 0) {
          const defenderDamage =
            defenderStength * (defenceUnit.hitPoints / 100);

          const defenderDamageAfterTerrain =
            defenderDamage / TerrainBonus(attackTerrain);

          attackUnit.hitPoints =
            attackUnit.hitPoints - defenderDamageAfterTerrain;
        }
      }
    </script>

    <script>
      const EventListener = (event) => {
        const { key } = event;
        const { path, currentSelectedUnitTile } = GlobalState;
        event.preventDefault();
        event.stopPropagation();

        if (
          ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].find(
            (command) => command === key
          )
        ) {
          const nextTileNumber = GetNextTileNumber(key);
          const nextTileElem = document.getElementById(
            `tile-${nextTileNumber}`
          );

          if (!nextTileElem) {
            return;
          }

          if (IsUndoMove(key, nextTileNumber)) {
            UndoMove(nextTileElem);
            return;
          }

          if (AlreadyMovedOnTile(nextTileNumber)) {
            return;
          }

          if (EnemyUnitBlocking(nextTileElem)) {
            return;
          }

          if (!CanMoveInTerrain(nextTileElem)) {
            return;
          }

          if (ReachedMovementRange()) {
            return;
          }

          AddPath(key, nextTileElem);

          return;
        }

        if (key === 'Enter') {
          const currentTile = document.getElementById(
            `tile-${GlobalState.currentTileId}`
          );

          if (TileIsOccupied(currentTile)) {
            return;
          }

          RemoveUnitElement();

          if (CheckRangeAttack()) {
            ResetPath();

            if (AdjacentEnemyUnits({ range: true })) {
              AddUnitElement({
                hasMoved: false,
                flipped: GlobalState.playerTurn === 2,
              });
              SelectTargetEnemy();
              return;
            } else {
              AddUnitElement({
                hasMoved: true,
                flipped: GlobalState.playerTurn === 2,
              });
              ResetSelectedTile();
              return;
            }
          }
          ResetPath();
          PlayMovementSound();

          if (AdjacentEnemyUnits()) {
            AddUnitElement({
              hasMoved: false,
              flipped: GlobalState.playerTurn === 2,
            });
            SelectTargetEnemy();
          } else {
            AddUnitElement({
              hasMoved: true,
              flipped: GlobalState.playerTurn === 2,
            });
            ResetSelectedTile();
          }

          return;
        } else {
          DeselectUnit();
        }

        if (key === 'Escape') {
          DeselectUnit();
          return;
        }
      };
    </script>

    <script>
      /* Game Interactive Logic */
      const SelectUnit = (event) => {
        const { target } = event;
        const { currentSelectedUnitTile, path, currentTileId } = GlobalState;

        if (currentSelectedUnitTile) {
          document.removeEventListener('keydown', EventListener);
          GlobalState.currentSelectedUnitTile.addEventListener(
            'mousedown',
            SelectUnit
          );

          ResetPath();
          ResetSelectedTile();
        }

        GlobalState.currentSelectedUnitTile = target;
        GlobalState.currentSelectedUnitElement =
          target.querySelector('div.unit');
        GlobalState.currentTileId = GetTileId(target);

        target.removeEventListener('mousedown', SelectUnit);

        const tileData = AddTileData(target, 'start');
        GlobalState.path.push(tileData);

        GlobalState.currentSelectedUnitTile
          .querySelector('.path')
          .classList.add('path__highlighted');

        document.addEventListener('keydown', EventListener);
      };
    </script>

    <script>
      /* Initial values */
      const startPositionsPlayer1 = [
        { tile: '84', unit: new Unit('infantry') },
        { tile: '85', unit: new Unit('infantry') },
        { tile: '86', unit: new Unit('infantry') },
        { tile: '123', unit: new Unit('tank') },
        { tile: '124', unit: new Unit('tank') },
        { tile: '162', unit: new Unit('rpg') },
        { tile: '163', unit: new Unit('rpg') },
        { tile: '444', unit: new Unit('battleship') },
        { tile: '245', unit: new Unit('rockets') },
      ];

      const startPositionsPlayer2 = [
        { tile: '93', unit: new Unit('infantry') },
        { tile: '94', unit: new Unit('infantry') },
        { tile: '95', unit: new Unit('infantry') },
        { tile: '135', unit: new Unit('tank') },
        { tile: '134', unit: new Unit('tank') },
        { tile: '173', unit: new Unit('rpg') },
        { tile: '131', unit: new Unit('rpg') },
        { tile: '455', unit: new Unit('battleship') },
        { tile: '365', unit: new Unit('infantry') },
        { tile: '324', unit: new Unit('tank') },
        { tile: '132', unit: new Unit('rockets') },
      ];

      document
        .getElementById('stats-player')
        .classList.add(
          `color-${GlobalState.playerColors[GlobalState.playerTurn]}`
        );

      startPositionsPlayer1.forEach(({ tile, unit }) => {
        const terrainElement = document.getElementById(`tile-${tile}`);
        //const unitImage = CreateUnitImage(unit, 1);
        const unitElement = CreateUnitElement(unit, 1);

        terrainElement.appendChild(unitElement);
        unit.tileElement = terrainElement;
        SetHitPoints(unit);

        GlobalState.units[1][unit.id] = unit;

        terrainElement.addEventListener('mousedown', SelectUnit);
        unit.tileElement = terrainElement;
      });

      startPositionsPlayer2.forEach(({ tile, unit }) => {
        const terrainElement = document.getElementById(`tile-${tile}`);
        const unitElement = CreateUnitElement(unit, 2);

        terrainElement.appendChild(unitElement);
        unit.tileElement = terrainElement;
        SetHitPoints(unit);

        GlobalState.units[2][unit.id] = unit;
        unit.tileElement = terrainElement;
        //terrainElement.addEventListener('mousedown', SelectUnit);
      });
    </script>
    <script>
      document.getElementById('end-turn').addEventListener('click', EndTurn);
    </script>
  </body>
</html>
