<html>
  <head>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="stats" class="stats">
      <div id="stats-day" class="stats-item">DAY: 1</div>
      <div id="stats-player" class="stats-item">PLAYER 1</div>
      <button id="end-turn" class="stats-button">End turn</button>
    </div>
    <div id="map" class="grid-container"></div>
    <div id="unit-action-modal" class="hidden">
      <div class="unit-action-modal__option">Attack</div>
      <div class="delimeter"></div>
      <div class="unit-action-modal__option">No Attack</div>
    </div>

    <!-- <script src="src/Terrain/RoadTerrain.js"></script>
    <script src="src/Terrain/GenerateMap.js"></script>
    <script src="src/Terrain/WaterAnimation.js"></script>
    <script src="src/Terrain/SetupTerrain.js"></script>

    <script src="src/Classes/TileDataClass.js"></script>
    <script src="src/Classes/UnitClass.js"></script>

    <script src="src/Audio.js"></script> -->
    <script>
      /* Functions */

      function GenerateUnitId() {
        return 'unitId-' + Date.now() + '-' + Math.floor(Math.random() * 10000);
      }

      function GetUnitLogic(type = '') {
        if (type === 'infantry') {
          return {
            movementRange: 3,
            canMoveInTerrain: ['field', 'forest', 'mountain', 'road', 'shore'],
          };
        }
        if (type === 'tank') {
          return {
            movementRange: 6,
            canMoveInTerrain: ['field', 'forest', 'road', 'shore'],
          };
        }
        if (type === 'rpg') {
          return {
            movementRange: 2,
            canMoveInTerrain: ['field', 'forest', 'mountain', 'road', 'shore'],
          };
        }
        if (type === 'rockets') {
          return {
            movementRange: 6,
            canMoveInTerrain: ['field', 'forest', 'road', 'shore'],
            directAttack: false,
            attackRange: 5,
            minAttackRange: 2,
          };
        }
        if (type === 'battleship') {
          return {
            movementRange: 5,
            canMoveInTerrain: ['water'],
            directAttack: false,
            attackRange: 6,
            minAttackRange: 2,
          };
        }

        return { movementRange: 0, canMoveInTerrain: [] };
      }

      function SetHitPoints(unit) {
        const unitElement = unit.tileElement.querySelector('div.unit');
        const hp = unitElement.querySelector('span.hp');

        const hitPoints = Math.round(Number(unit.hitPoints));

        if (hitPoints === 100) {
          hp.innerHTML = String(hitPoints);
        } else if (hitPoints > 9) {
          hp.innerHTML = String(hitPoints).substring(0, 2);
        } else {
          hp.innerHTML = String(hitPoints);
        }
      }

      function CreateUnitElement(unit, player) {
        const element = document.createElement('div');
        element.classList.add('unit');
        element.setAttribute('player', player);

        const unitImage = CreateUnitImage(unit, player);

        const hpElement = document.createElement('span');
        hpElement.classList.add('hp');
        hpElement.style.zIndex = '2';

        const color = GlobalState.playerColors[player];
        hpElement.classList.add(`color-${color}`);

        element.appendChild(unitImage);
        element.appendChild(hpElement);

        element.id = unit.id;

        return element;
      }

      function CreateUnitImage(unit, player) {
        const { type, id } = unit;
        const img = document.createElement('img');

        const color = GlobalState.playerColors[player];

        if (type === 'infantry') {
          img.src = `units/${type}_${color}.png`;
        } else if (type === 'rpg') {
          img.src = `units/infantry_${type}_${color}.png`;
        } else if (type === 'rockets') {
          img.src = `units/${type}_${color}.png`;
        } else {
          img.src = `units/${type}.png`;
        }

        img.classList.add('overlay-image');
        img.classList.add('unit-image');

        if (player === 2) {
          img.classList.add('flipped-right');
        }

        return img;
      }

      function AddTileData(elem, command) {
        const id = elem.id.split('-')[1];
        const terrain = window
          .getComputedStyle(elem, null)
          .getPropertyValue('background-color');
        const tileData = new TileData(id, terrain, elem, command);
        return tileData;
      }

      function GetNextTileNumber(key) {
        const currentTileId = Number(
          GlobalState.currentTileId ||
            GlobalState.currentSelectedUnitTile.id.split('-')[1]
        );

        switch (key) {
          case 'ArrowUp':
            return currentTileId - 40;
          case 'ArrowDown':
            return currentTileId + 40;
          case 'ArrowLeft':
            return currentTileId - 1;
          case 'ArrowRight':
            return currentTileId + 1;
          default:
            -1;
        }
      }

      function GetUnitIDFromTerrainElement(terrainElement) {
        return terrainElement.querySelector(`div.unit`)?.id;
      }

      function GetTileId(terrainElement) {
        return Number(terrainElement.id.split('-')[1]);
      }

      function GetTerrainType(terrainElement) {
        const terrain = Array.from(terrainElement.classList)
          .find((c) => c.split('-')[0] === 'terrain')
          .split('-')[1];

        return terrain;
      }

      function CanMoveInTerrain(terrainElement) {
        const id = GetUnitIDFromTerrainElement(
          GlobalState.currentSelectedUnitTile
        );

        const unit = GlobalState.units[GlobalState.playerTurn][id];

        if (!unit) {
          console.log(`No unit found for ${id}`);
          return false;
        }
        const terrain = Array.from(terrainElement.classList).find(
          (c) => c.split('-')[0] === 'terrain'
        );

        if (!terrain) {
          console.log(`Not a terrain: ${terrain}`);
          return false;
        }

        const canMove = !!unit.canMoveInTerrain.find(
          (t) => t === terrain.split('-')[1]
        );

        return canMove;
      }

      function IsUndoMove(key, nextTile) {
        const { path } = GlobalState;

        const lastTile = path[path.length - 1];

        switch (key) {
          case 'ArrowUp':
            return lastTile.command === 'ArrowDown';
          case 'ArrowDown':
            return lastTile.command === 'ArrowUp';
          case 'ArrowLeft':
            return lastTile.command === 'ArrowRight';
          case 'ArrowRight':
            return lastTile.command === 'ArrowLeft';
          default:
            return false;
        }
      }

      function UndoMove(elem) {
        const { path } = GlobalState;

        const lastTile = path[path.length - 1];

        document
          .getElementById(`tile-${lastTile.id}`)
          .querySelector('.path')
          .classList.remove('path__highlighted');

        GlobalState.path.pop();
        GlobalState.currentTileId = Number(elem.id.split('-')[1]);
      }

      function AlreadyMovedOnTile(nextTileNumber) {
        const { path } = GlobalState;

        return !!path.find(
          (tileData) => Number(tileData.id) === nextTileNumber
        );
      }

      function TileIsOccupied(elem) {
        const selectedUnitId = GlobalState.currentSelectedUnitElement.id;

        const idOnTile = GetUnitIDFromTerrainElement(elem);

        return idOnTile && idOnTile !== selectedUnitId;
      }

      function AddPath(key, nextTileElem) {
        GlobalState.currentTileId = Number(nextTileElem.id.split('-')[1]);
        const tileData = AddTileData(nextTileElem, key);
        GlobalState.path.push(tileData);

        nextTileElem.querySelector('.path').classList.add('path__highlighted');

        //nextTileElem.style.backgroundColor = 'purple';
      }

      function RemoveUnitElement() {
        document.removeEventListener('keydown', SelectedUnitEventListener);

        const unitElement =
          GlobalState.currentSelectedUnitTile.querySelector('div.unit');

        GlobalState.currentSelectedUnitElement = unitElement;

        GlobalState.currentSelectedUnitTile.removeChild(unitElement);
      }

      function AddUnitElement(settings = {}) {
        const { currentTileId, units, playerTurn } = GlobalState;
        const terrainElement =
          settings.tile || document.getElementById(`tile-${currentTileId}`);
        const unitElement = GlobalState.currentSelectedUnitElement;
        const id = unitElement.id;

        units[playerTurn][id].tileElement = terrainElement;

        terrainElement.appendChild(unitElement);
        if (settings.canMove) {
          terrainElement.addEventListener('mousedown', SelectUnit);
        }
        if (settings.hasMoved) {
          unitElement.classList.add('hasMoved');
        }

        if (settings.flipped) {
          unitElement
            .querySelector('img.unit-image')
            .classList.add('flipped-right');
          //unitElement.classList.add('flipped-right');
        }
      }

      function SetPathForAnimation() {
        const { path } = GlobalState;
        GlobalState.animation.path = [...path];
      }

      function ResetPath() {
        GlobalState.path.forEach((tile) => {
          tile.element
            .querySelector('.path')
            .classList.remove('path__highlighted');
          //tile.element.style.backgroundColor = tile.terrainColor;
        });
        GlobalState.path = [];
      }

      function ResetSelectedTile() {
        GlobalState.currentSelectedUnitTile = null;
        GlobalState.currentTileId = null;
        GlobalState.currentSelectedUnitElement = null;
      }

      function ReachedMovementRange() {
        const { currentSelectedUnitElement, path, playerTurn } = GlobalState;

        const currentUnit =
          GlobalState.units[playerTurn][currentSelectedUnitElement.id];

        const terrainInPath = path.map((tileData) =>
          GetTerrainType(tileData.element)
        );

        let reduceField = 0;
        let reduceForest = 0;
        let reduceMountain = 0;
        let reduceShore = 0;

        const containsMountain = terrainInPath.some((t) => t === 'mountain');
        const containsForest = terrainInPath.some((t) => t === 'forest');
        const containsField = terrainInPath.some((t) => t === 'field');
        const containsShore = terrainInPath.some((t) => t === 'shore');

        if (currentUnit.type === 'tank') {
          reduceField = containsField ? 0 : 0;
          reduceForest = containsForest ? 2 : 0;
          reduceMountain = containsMountain ? 0 : 0;
        } else if (currentUnit.type === 'infantry') {
          reduceField = containsField ? 0 : 0;
          reduceForest = containsForest ? 0 : 0;
          reduceMountain = containsMountain ? 1 : 0;
        } else if (currentUnit.type === 'rpg') {
          reduceField = containsField ? 0 : 0;
          reduceForest = containsForest ? 0 : 0;
          reduceMountain = containsMountain ? 1 : 0;
        } else if (currentUnit.type === 'rockets') {
          reduceField = containsField ? 1 : 0;
          reduceForest = containsForest ? 3 : 0;
          reduceMountain = containsMountain ? 1 : 0;
          reduceShore = containsShore ? 2 : 0;
        }

        const reduction =
          Number(reduceField) +
          Number(reduceForest) +
          Number(reduceMountain) +
          Number(reduceShore);

        return path.length >= currentUnit.movementRange + 1 - reduction;
      }

      function EndTurn() {
        const { playerTurn, numberOfPlayers, units } = GlobalState;

        DeselectUnit();

        // Remove event listeners for the current player's units
        Object.keys(units[playerTurn]).forEach((id) => {
          units[playerTurn][id].tileElement.removeEventListener(
            'mousedown',
            SelectUnit
          );
          const movedUnit =
            units[playerTurn][id].tileElement.querySelector('.hasMoved');

          if (movedUnit) {
            movedUnit.classList.remove('hasMoved');
          }
        });

        const previousPlayer = GlobalState.playerTurn;

        // Update the player turn
        if (playerTurn === numberOfPlayers) {
          GlobalState.turn++;
          GlobalState.playerTurn = 1;
        } else {
          GlobalState.playerTurn++;
        }

        // Update the stats display
        document.getElementById('stats-day').innerHTML =
          'DAY ' + GlobalState.turn;
        document.getElementById('stats-player').innerHTML =
          'PLAYER ' + GlobalState.playerTurn;

        const previousColor = GlobalState.playerColors[previousPlayer];
        const newColor = GlobalState.playerColors[GlobalState.playerTurn];

        document
          .getElementById('stats-player')
          .classList.remove(`color-${previousColor}`);
        document
          .getElementById('stats-player')
          .classList.add(`color-${newColor}`);

        // Add event listeners for the new player's units
        Object.keys(units[GlobalState.playerTurn]).forEach((id) => {
          units[GlobalState.playerTurn][id].tileElement.addEventListener(
            'mousedown',
            SelectUnit
          );
        });
      }

      function GetUnitFromElement(element) {
        return element.querySelector('div.unit');
      }

      function DeselectUnit() {
        document.removeEventListener('keydown', SelectedUnitEventListener);
        GlobalState.currentSelectedUnitTile?.addEventListener(
          'mousedown',
          SelectUnit
        );

        ResetPath();
        ResetSelectedTile();
      }

      function MapDirection(id) {
        const { currentTileId } = GlobalState;
        if (currentTileId - 1 === id) {
          return 'ArrowLeft';
        }
        if (currentTileId + 1 === id) {
          return 'ArrowRight';
        }
        if (currentTileId - 40 === id) {
          return 'ArrowUp';
        }
        if (currentTileId + 40 === id) {
          return 'ArrowDown';
        }
      }

      function RemoveUnitActionModalEvents() {
        document.removeEventListener('keydown', UnitActionModalEvents);

        const modal = document.getElementById('unit-action-modal');

        const actions = modal.querySelectorAll('div.unit-action-modal__option');

        const attack = actions[0];
        const noAttack = actions[1];

        attack.removeEventListener('click', Attack);
        noAttack.removeEventListener('click', NoAttack);
      }

      function CloseUnitActionModal() {
        RemoveUnitActionModalEvents();
        ResetTargetEnemy();

        const modal = document.getElementById('unit-action-modal');
        modal.classList.add('hidden');
      }

      function UnitActionModalEvents(event) {
        const { key } = event;
        if (key === 'Escape') {
          CloseUnitActionModal();
          SelectTargetEnemy();
        }

        if (key === 'Enter') {
          PreAttack();
        }
      }

      function PreAttack() {
        RemoveUnitActionModalEvents();
        CloseUnitActionModal();
        Attack();
        //RemoveUnitElement();
        if (GlobalState.currentSelectedUnitElement) {
          AddUnitElement({
            hasMoved: true,
            canMove: false,
            flipped: GlobalState.playerTurn === 2,
          });
        }

        ResetSelectedTile();
      }

      function NoAttack() {
        RemoveUnitActionModalEvents();
        CloseUnitActionModal();
        //RemoveUnitElement();
        AddUnitElement({
          hasMoved: true,
          canMove: false,
          flipped: GlobalState.playerTurn === 2,
        });
        ResetSelectedTile();
      }

      function OpenUnitActionModal() {
        const { currentTileId } = GlobalState;
        const currentTile = document.getElementById(`tile-${currentTileId}`);

        document.getElementById('map').style.overflow = 'hidden';

        const modal = document.getElementById('unit-action-modal');
        modal.classList.remove('hidden');

        const rect = currentTile.getBoundingClientRect();
        modal.style.left = rect.left + 50 + 'px';
        modal.style.top = rect.top + 50 + 'px';

        const actions = modal.querySelectorAll('div.unit-action-modal__option');

        const attack = actions[0];
        const noAttack = actions[1];

        attack.addEventListener('click', PreAttack);
        noAttack.addEventListener('click', NoAttack);
        document.addEventListener('keydown', UnitActionModalEvents);
      }

      function ResetTargetEnemy() {
        const { adjacentEnemyTiles } = GlobalState;

        adjacentEnemyTiles.forEach(({ tileElement }) => {
          tileElement
            .querySelector('.path')
            .classList.remove('path__highlighted--attack'); // Change to image later
        });
      }

      function HandleSelectRangedTarget(command) {
        const { adjacentEnemyTiles, targetEnemyUnitTile, currentTileId } =
          GlobalState;

        const currentEnemyTileId = adjacentEnemyTiles.find(
          ({ tileElement }) =>
            GetTileId(tileElement) === GetTileId(targetEnemyUnitTile)
        );

        const index = adjacentEnemyTiles.indexOf(currentEnemyTileId);

        if (command === 'ArrowRight') {
          const nextIndex =
            index + 1 === adjacentEnemyTiles.length ? 0 : index + 1;
          return adjacentEnemyTiles[nextIndex];
        }
        if (command === 'ArrowLeft') {
          const nextIndex =
            index - 1 < 0 ? adjacentEnemyTiles.length - 1 : index - 1;
          return adjacentEnemyTiles[nextIndex];
        }
        if (command === 'ArrowDown') {
          const nextIndex =
            index - 1 < 0 ? adjacentEnemyTiles.length - 1 : index - 1;
          return adjacentEnemyTiles[nextIndex];
        }
        if (command === 'ArrowUp') {
          const nextIndex =
            index + 1 === adjacentEnemyTiles.length ? 0 : index + 1;
          return adjacentEnemyTiles[nextIndex];
        }
        return targetEnemyUnitTile;
      }

      function ChangeTargetEnemy() {
        const { key } = event;
        const {
          adjacentEnemyTiles,
          currentSelectedUnitElement,
          units,
          playerTurn,
        } = GlobalState;

        const unit = units[playerTurn][currentSelectedUnitElement.id];
        const actions = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];

        if (unit.directAttack === false) {
          if (actions.find((command) => command === key)) {
            const enemyTile = HandleSelectRangedTarget(key);

            if (enemyTile) {
              ResetTargetEnemy();

              enemyTile.tileElement
                .querySelector('.path')
                .classList.add('path__highlighted--attack'); // Change to image later

              GlobalState.targetEnemyUnitTile = enemyTile.tileElement;
            }
          }
        } else {
          if (actions.find((command) => command === key)) {
            const enemyTile = adjacentEnemyTiles.find(
              (tile) => tile.direction === key
            );

            if (enemyTile) {
              ResetTargetEnemy();

              enemyTile.tileElement
                .querySelector('.path')
                .classList.add('path__highlighted--attack'); // Change to image later

              GlobalState.targetEnemyUnitTile = enemyTile.tileElement;
            }
          }
        }

        if (key === 'Enter') {
          document.removeEventListener('keydown', ChangeTargetEnemy);
          OpenUnitActionModal();
          return;
        }

        if (key === 'Escape') {
          document.removeEventListener('keydown', ChangeTargetEnemy);

          adjacentEnemyTiles.forEach(({ tileElement }) => {
            tileElement
              .querySelector('.path')
              .classList.remove('path__highlighted--attack'); // Change to image later
          });

          AddUnitElement({
            tile: GlobalState.currentSelectedUnitTile,
            flipped: GlobalState.playerTurn === 2,
            hasMoved: false,
            canMove: true,
          });

          ResetSelectedTile();
        }
      }

      function SelectTargetEnemy() {
        const { currentTileId, adjacentEnemyTiles } = GlobalState;
        const currentTile = document.getElementById(`tile-${currentTileId}`);

        document.getElementById('map').style.overflow = 'hidden';

        const firstEnemy = adjacentEnemyTiles[0];
        firstEnemy.tileElement
          .querySelector('.path')
          .classList.add('path__highlighted--attack');

        GlobalState.targetEnemyUnitTile = firstEnemy.tileElement;

        if (adjacentEnemyTiles.length > 1) {
          document.addEventListener('keydown', ChangeTargetEnemy);
        } else {
          OpenUnitActionModal();
        }
      }

      function AdjacentEnemyUnits(options = {}) {
        const { currentTileId, playerTurn, currentSelectedUnitElement, units } =
          GlobalState;

        const unit = units[playerTurn][currentSelectedUnitElement.id];

        let surroundingTiles = [];

        if (unit.attackRange && !options.range) {
          return false;
        }

        if (unit.attackRange) {
          const attackRange = unit.attackRange;

          for (let i = attackRange; i > -1; i--) {
            let up;
            let down;

            if (i !== 0) {
              up = currentTileId + -40 * i;
              down = currentTileId + 40 * i;
              surroundingTiles.push(up);
              surroundingTiles.push(down);

              // const upElem = document.getElementById('tile-' + up);
              // AddPath('ArrowUp', upElem);

              // const downElem = document.getElementById('tile-' + down);
              // AddPath('ArrowUp', downElem);
            }

            const rowTiles = attackRange - i;

            for (let j = 1; j < rowTiles + 1; j++) {
              if (i === 0) {
                const left = currentTileId - j;
                const right = currentTileId + j;
                surroundingTiles.push(left);
                surroundingTiles.push(right);
                // AddPath('ArrowUp', document.getElementById('tile-' + left));
                // AddPath('ArrowUp', document.getElementById('tile-' + right));

                const hej = 0;
              } else {
                const upLeft = up - j;
                const upRight = up + j;

                const downLeft = down - j;
                const downRight = down + j;

                // AddPath('ArrowUp', document.getElementById('tile-' + upLeft));
                // AddPath('ArrowUp', document.getElementById('tile-' + upRight));
                // AddPath('ArrowUp', document.getElementById('tile-' + downLeft));
                // AddPath(
                //   'ArrowUp',
                //   document.getElementById('tile-' + downRight)
                // );

                surroundingTiles.push(upLeft);
                surroundingTiles.push(upRight);
                surroundingTiles.push(downLeft);
                surroundingTiles.push(downRight);
              }
            }
          }
        } else {
          surroundingTiles = [
            currentTileId - 1,
            currentTileId + 1,
            currentTileId - 40,
            currentTileId + 40,
          ];
        }

        surroundingTiles = surroundingTiles
          .map((id) => ({
            tileElement: document.getElementById(`tile-${id}`),
            direction: options.range ? null : MapDirection(id),
          }))
          .filter((tile) => !!tile.tileElement);

        const enemyTiles = surroundingTiles.filter(
          ({ tileElement, direction }) => {
            const unit = GetUnitFromElement(tileElement);
            if (unit) {
              if (Number(unit.getAttribute('player')) !== playerTurn) {
                return true;
              }
              return false;
            }
            return false;
          }
        );

        if (!enemyTiles.length) {
          return false;
        }

        GlobalState.adjacentEnemyTiles = enemyTiles;

        return true;
      }

      function EnemyUnitBlocking(nextTile) {
        const unitElement = nextTile.querySelector('div.unit');

        if (!unitElement) {
          return false;
        }

        const player = unitElement.getAttribute('player');

        if (Number(player) === Number(GlobalState.playerTurn)) {
          return false;
        }

        return true;
      }

      function CheckRangeAttack() {
        const { currentSelectedUnitElement, playerTurn, path } = GlobalState;

        if (!currentSelectedUnitElement) {
          return false;
        }

        if (path.length > 1) {
          return false;
        }

        const unit =
          GlobalState.units[playerTurn][currentSelectedUnitElement.id];

        if (!unit.directAttack) {
          return true;
        }
      }
    </script>

    <!-- <script src="src/CombatLogic.js"></script>
    <script src="src/UnitAnimation.js"></script>

    <script src="src/SelectedUnitEventListener.js"></script>
    <script src="src/SelectUnitEventListener.js"></script>
    <script src="src/EndTurnEventListener.js"></script> -->

    <!-- <script src="src/SetupSettings.js"></script>
    <script src="src/GenerateUnits.js"></script> -->

    <script type="module" src="Main.js"></script>

    <script></script>
  </body>
</html>
